import _m0 from "protobufjs/minimal";
import { Duration } from "../protobuf/duration";
/**
 * Describes the cause of the error with structured details.
 *
 * Example of an error when contacting the "pubsub.googleapis.com" API when it
 * is not enabled:
 *
 *     { "reason": "API_DISABLED"
 *       "domain": "googleapis.com"
 *       "metadata": {
 *         "resource": "projects/123",
 *         "service": "pubsub.googleapis.com"
 *       }
 *     }
 *
 * This response indicates that the pubsub.googleapis.com API is not enabled.
 *
 * Example of an error that is returned when attempting to create a Spanner
 * instance in a region that is out of stock:
 *
 *     { "reason": "STOCKOUT"
 *       "domain": "spanner.googleapis.com",
 *       "metadata": {
 *         "availableRegions": "us-central1,us-east2"
 *       }
 *     }
 */
export interface ErrorInfo {
    /**
     * The reason of the error. This is a constant value that identifies the
     * proximate cause of the error. Error reasons are unique within a particular
     * domain of errors. This should be at most 63 characters and match a
     * regular expression of `[A-Z][A-Z0-9_]+[A-Z0-9]`, which represents
     * UPPER_SNAKE_CASE.
     */
    reason?: string | undefined;
    /**
     * The logical grouping to which the "reason" belongs. The error domain
     * is typically the registered service name of the tool or product that
     * generates the error. Example: "pubsub.googleapis.com". If the error is
     * generated by some common infrastructure, the error domain must be a
     * globally unique value that identifies the infrastructure. For Google API
     * infrastructure, the error domain is "googleapis.com".
     */
    domain?: string | undefined;
    /**
     * Additional structured details about this error.
     *
     * Keys should match /[a-zA-Z0-9-_]/ and be limited to 64 characters in
     * length. When identifying the current value of an exceeded limit, the units
     * should be contained in the key, not the value.  For example, rather than
     * {"instanceLimit": "100/request"}, should be returned as,
     * {"instanceLimitPerRequest": "100"}, if the client exceeds the number of
     * instances that can be created in a single (batch) request.
     */
    metadata?: Map<string, string> | undefined;
    _unknownFields?: {
        [key: number]: Uint8Array[];
    } | undefined;
}
export interface ErrorInfo_MetadataEntry {
    key: string;
    value: string;
    _unknownFields?: {
        [key: number]: Uint8Array[];
    } | undefined;
}
/**
 * Describes when the clients can retry a failed request. Clients could ignore
 * the recommendation here or retry when this information is missing from error
 * responses.
 *
 * It's always recommended that clients should use exponential backoff when
 * retrying.
 *
 * Clients should wait until `retry_delay` amount of time has passed since
 * receiving the error response before retrying.  If retrying requests also
 * fail, clients should use an exponential backoff scheme to gradually increase
 * the delay between retries based on `retry_delay`, until either a maximum
 * number of retries have been reached or a maximum retry delay cap has been
 * reached.
 */
export interface RetryInfo {
    /** Clients should wait at least this long between retrying the same request. */
    retry_delay?: Duration | undefined;
    _unknownFields?: {
        [key: number]: Uint8Array[];
    } | undefined;
}
/** Describes additional debugging info. */
export interface DebugInfo {
    /** The stack trace entries indicating where the error occurred. */
    stack_entries?: string[] | undefined;
    /** Additional debugging information provided by the server. */
    detail?: string | undefined;
    _unknownFields?: {
        [key: number]: Uint8Array[];
    } | undefined;
}
/**
 * Describes how a quota check failed.
 *
 * For example if a daily limit was exceeded for the calling project,
 * a service could respond with a QuotaFailure detail containing the project
 * id and the description of the quota limit that was exceeded.  If the
 * calling project hasn't enabled the service in the developer console, then
 * a service could respond with the project id and set `service_disabled`
 * to true.
 *
 * Also see RetryInfo and Help types for other details about handling a
 * quota failure.
 */
export interface QuotaFailure {
    /** Describes all quota violations. */
    violations?: QuotaFailure_Violation[] | undefined;
    _unknownFields?: {
        [key: number]: Uint8Array[];
    } | undefined;
}
/**
 * A message type used to describe a single quota violation.  For example, a
 * daily quota or a custom quota that was exceeded.
 */
export interface QuotaFailure_Violation {
    /**
     * The subject on which the quota check failed.
     * For example, "clientip:<ip address of client>" or "project:<Google
     * developer project id>".
     */
    subject?: string | undefined;
    /**
     * A description of how the quota check failed. Clients can use this
     * description to find more about the quota configuration in the service's
     * public documentation, or find the relevant quota limit to adjust through
     * developer console.
     *
     * For example: "Service disabled" or "Daily Limit for read operations
     * exceeded".
     */
    description?: string | undefined;
    _unknownFields?: {
        [key: number]: Uint8Array[];
    } | undefined;
}
/**
 * Describes what preconditions have failed.
 *
 * For example, if an RPC failed because it required the Terms of Service to be
 * acknowledged, it could list the terms of service violation in the
 * PreconditionFailure message.
 */
export interface PreconditionFailure {
    /** Describes all precondition violations. */
    violations?: PreconditionFailure_Violation[] | undefined;
    _unknownFields?: {
        [key: number]: Uint8Array[];
    } | undefined;
}
/** A message type used to describe a single precondition failure. */
export interface PreconditionFailure_Violation {
    /**
     * The type of PreconditionFailure. We recommend using a service-specific
     * enum type to define the supported precondition violation subjects. For
     * example, "TOS" for "Terms of Service violation".
     */
    type?: string | undefined;
    /**
     * The subject, relative to the type, that failed.
     * For example, "google.com/cloud" relative to the "TOS" type would indicate
     * which terms of service is being referenced.
     */
    subject?: string | undefined;
    /**
     * A description of how the precondition failed. Developers can use this
     * description to understand how to fix the failure.
     *
     * For example: "Terms of service not accepted".
     */
    description?: string | undefined;
    _unknownFields?: {
        [key: number]: Uint8Array[];
    } | undefined;
}
/**
 * Describes violations in a client request. This error type focuses on the
 * syntactic aspects of the request.
 */
export interface BadRequest {
    /** Describes all violations in a client request. */
    field_violations?: BadRequest_FieldViolation[] | undefined;
    _unknownFields?: {
        [key: number]: Uint8Array[];
    } | undefined;
}
/** A message type used to describe a single bad request field. */
export interface BadRequest_FieldViolation {
    /**
     * A path that leads to a field in the request body. The value will be a
     * sequence of dot-separated identifiers that identify a protocol buffer
     * field.
     *
     * Consider the following:
     *
     *     message CreateContactRequest {
     *       message EmailAddress {
     *         enum Type {
     *           TYPE_UNSPECIFIED = 0;
     *           HOME = 1;
     *           WORK = 2;
     *         }
     *
     *         optional string email = 1;
     *         repeated EmailType type = 2;
     *       }
     *
     *       string full_name = 1;
     *       repeated EmailAddress email_addresses = 2;
     *     }
     *
     * In this example, in proto `field` could take one of the following values:
     *
     * * `full_name` for a violation in the `full_name` value
     * * `email_addresses[1].email` for a violation in the `email` field of the
     *   first `email_addresses` message
     * * `email_addresses[3].type[2]` for a violation in the second `type`
     *   value in the third `email_addresses` message.
     *
     * In JSON, the same values are represented as:
     *
     * * `fullName` for a violation in the `fullName` value
     * * `emailAddresses[1].email` for a violation in the `email` field of the
     *   first `emailAddresses` message
     * * `emailAddresses[3].type[2]` for a violation in the second `type`
     *   value in the third `emailAddresses` message.
     */
    field?: string | undefined;
    /** A description of why the request element is bad. */
    description?: string | undefined;
    _unknownFields?: {
        [key: number]: Uint8Array[];
    } | undefined;
}
/**
 * Contains metadata about the request that clients can attach when filing a bug
 * or providing other forms of feedback.
 */
export interface RequestInfo {
    /**
     * An opaque string that should only be interpreted by the service generating
     * it. For example, it can be used to identify requests in the service's logs.
     */
    request_id?: string | undefined;
    /**
     * Any data that was used to serve this request. For example, an encrypted
     * stack trace that can be sent back to the service provider for debugging.
     */
    serving_data?: string | undefined;
    _unknownFields?: {
        [key: number]: Uint8Array[];
    } | undefined;
}
/** Describes the resource that is being accessed. */
export interface ResourceInfo {
    /**
     * A name for the type of resource being accessed, e.g. "sql table",
     * "cloud storage bucket", "file", "Google calendar"; or the type URL
     * of the resource: e.g. "type.googleapis.com/google.pubsub.v1.Topic".
     */
    resource_type?: string | undefined;
    /**
     * The name of the resource being accessed.  For example, a shared calendar
     * name: "example.com_4fghdhgsrgh@group.calendar.google.com", if the current
     * error is
     * [google.rpc.Code.PERMISSION_DENIED][google.rpc.Code.PERMISSION_DENIED].
     */
    resource_name?: string | undefined;
    /**
     * The owner of the resource (optional).
     * For example, "user:<owner email>" or "project:<Google developer project
     * id>".
     */
    owner?: string | undefined;
    /**
     * Describes what error is encountered when accessing this resource.
     * For example, updating a cloud project may require the `writer` permission
     * on the developer console project.
     */
    description?: string | undefined;
    _unknownFields?: {
        [key: number]: Uint8Array[];
    } | undefined;
}
/**
 * Provides links to documentation or for performing an out of band action.
 *
 * For example, if a quota check failed with an error indicating the calling
 * project hasn't enabled the accessed service, this can contain a URL pointing
 * directly to the right place in the developer console to flip the bit.
 */
export interface Help {
    /** URL(s) pointing to additional information on handling the current error. */
    links?: Help_Link[] | undefined;
    _unknownFields?: {
        [key: number]: Uint8Array[];
    } | undefined;
}
/** Describes a URL link. */
export interface Help_Link {
    /** Describes what the link offers. */
    description?: string | undefined;
    /** The URL of the link. */
    url?: string | undefined;
    _unknownFields?: {
        [key: number]: Uint8Array[];
    } | undefined;
}
/**
 * Provides a localized error message that is safe to return to the user
 * which can be attached to an RPC error.
 */
export interface LocalizedMessage {
    /**
     * The locale used following the specification defined at
     * https://www.rfc-editor.org/rfc/bcp/bcp47.txt.
     * Examples are: "en-US", "fr-CH", "es-MX"
     */
    locale?: string | undefined;
    /** The localized error message in the above locale. */
    message?: string | undefined;
    _unknownFields?: {
        [key: number]: Uint8Array[];
    } | undefined;
}
export declare const ErrorInfo: {
    encode(message: ErrorInfo, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ErrorInfo;
    fromJSON(object: any): ErrorInfo;
    toJSON(message: ErrorInfo): unknown;
};
export declare const ErrorInfo_MetadataEntry: {
    encode(message: ErrorInfo_MetadataEntry, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ErrorInfo_MetadataEntry;
    fromJSON(object: any): ErrorInfo_MetadataEntry;
    toJSON(message: ErrorInfo_MetadataEntry): unknown;
};
export declare const RetryInfo: {
    encode(message: RetryInfo, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): RetryInfo;
    fromJSON(object: any): RetryInfo;
    toJSON(message: RetryInfo): unknown;
};
export declare const DebugInfo: {
    encode(message: DebugInfo, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): DebugInfo;
    fromJSON(object: any): DebugInfo;
    toJSON(message: DebugInfo): unknown;
};
export declare const QuotaFailure: {
    encode(message: QuotaFailure, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QuotaFailure;
    fromJSON(object: any): QuotaFailure;
    toJSON(message: QuotaFailure): unknown;
};
export declare const QuotaFailure_Violation: {
    encode(message: QuotaFailure_Violation, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): QuotaFailure_Violation;
    fromJSON(object: any): QuotaFailure_Violation;
    toJSON(message: QuotaFailure_Violation): unknown;
};
export declare const PreconditionFailure: {
    encode(message: PreconditionFailure, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): PreconditionFailure;
    fromJSON(object: any): PreconditionFailure;
    toJSON(message: PreconditionFailure): unknown;
};
export declare const PreconditionFailure_Violation: {
    encode(message: PreconditionFailure_Violation, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): PreconditionFailure_Violation;
    fromJSON(object: any): PreconditionFailure_Violation;
    toJSON(message: PreconditionFailure_Violation): unknown;
};
export declare const BadRequest: {
    encode(message: BadRequest, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): BadRequest;
    fromJSON(object: any): BadRequest;
    toJSON(message: BadRequest): unknown;
};
export declare const BadRequest_FieldViolation: {
    encode(message: BadRequest_FieldViolation, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): BadRequest_FieldViolation;
    fromJSON(object: any): BadRequest_FieldViolation;
    toJSON(message: BadRequest_FieldViolation): unknown;
};
export declare const RequestInfo: {
    encode(message: RequestInfo, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): RequestInfo;
    fromJSON(object: any): RequestInfo;
    toJSON(message: RequestInfo): unknown;
};
export declare const ResourceInfo: {
    encode(message: ResourceInfo, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): ResourceInfo;
    fromJSON(object: any): ResourceInfo;
    toJSON(message: ResourceInfo): unknown;
};
export declare const Help: {
    encode(message: Help, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): Help;
    fromJSON(object: any): Help;
    toJSON(message: Help): unknown;
};
export declare const Help_Link: {
    encode(message: Help_Link, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): Help_Link;
    fromJSON(object: any): Help_Link;
    toJSON(message: Help_Link): unknown;
};
export declare const LocalizedMessage: {
    encode(message: LocalizedMessage, writer?: _m0.Writer): _m0.Writer;
    decode(input: _m0.Reader | Uint8Array, length?: number): LocalizedMessage;
    fromJSON(object: any): LocalizedMessage;
    toJSON(message: LocalizedMessage): unknown;
};
